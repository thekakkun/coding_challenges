import time

start_time = time.time()


def p061(cycle_length, history=None, pool=None):
    """Cyclical figurate numbers

    Problem 61

    Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
    Triangle        P_(3,n)=n(n+1)/2        1, 3, 6, 10, 15, ...
    Square          P_(4,n)=n^2             1, 4, 9, 16, 25, ...
    Pentagonal 	  	P_(5,n)=n(3n−1)/2       1, 5, 12, 22, 35, ...
    Hexagonal 	  	P_(6,n)=n(2n−1)         1, 6, 15, 28, 45, ...
    Heptagonal 	  	P_(7,n)=n(5n−3)/2       1, 7, 18, 34, 55, ...
    Octagonal 	  	P_(8,n)=n(3n−2)         1, 8, 21, 40, 65, ...

    The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

        The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
        Each polygonal type: triangle (P_(3,127)=8128), square (P_(4,91)=8281), and pentagonal (P_(5,44)=2882), is represented by a different number in the set.
        This is the only set of 4-digit numbers with this property.

    Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
    """

    if history is None:
        history = []
        polygonal_numbers = []

        for i in range(cycle_length):
            polygonal_numbers.append(return_polygons(i + 3, 1000, 10000))

        for num_list in polygonal_numbers:
            for num in num_list:
                pool = polygonal_numbers.copy()
                pool.remove(num_list)
                if not pool:
                    continue
                history.append(num)
                if p061(cycle_length, history, pool):
                    return p061(cycle_length, history, pool)
                else:
                    history = []
                    continue

    elif len(history) == cycle_length:
        if is_cyclic(history[-1], history[0]):
            return sum(history)
        else:
            return False

    else:
        for num_list in pool:
            valid_numbers = [x for x in num_list if is_cyclic(history[-1], x)]
            if not valid_numbers:
                continue
            for num in valid_numbers:
                new_pool = pool.copy()
                new_pool.remove(num_list)
                history.append(num)
                if p061(cycle_length, history, new_pool):
                    return p061(cycle_length, history, new_pool)
                else:
                    history.pop(-1)
                    continue


def find_chain(start, pool, cycle_length):
    if cycle_length == 0:
        return start
    for num_list in pool:
        valid_numbers = [x for x in num_list if is_cyclic(start, x)]
        for num in valid_numbers:
            new_pool = pool.copy()
            new_pool.remove(num_list)
            return find_chain(num, new_pool, cycle_length)


def return_polygons(shape, start, end):
    number_list = []
    if shape == 3:
        i = 0
        while True:
            p_i = i * (i + 1) // 2
            if end <= p_i:
                return number_list
            elif start <= p_i:
                number_list.append(p_i)
            i += 1

    elif shape == 4:
        i = 0
        while True:
            p_i = i ** 2
            if end <= p_i:
                return number_list
            elif start <= p_i:
                number_list.append(p_i)
            i += 1

    elif shape == 5:
        i = 0
        while True:
            p_i = i * (3 * i - 1) // 2
            if end <= p_i:
                return number_list
            elif start <= p_i:
                number_list.append(p_i)
            i += 1

    elif shape == 6:
        i = 0
        while True:
            p_i = i * (2 * i - 1)
            if end <= p_i:
                return number_list
            elif start <= p_i:
                number_list.append(p_i)
            i += 1
    elif shape == 7:
        i = 0
        while True:
            p_i = i * (5 * i - 3) // 2
            if end <= p_i:
                return number_list
            elif start <= p_i:
                number_list.append(p_i)
            i += 1

    elif shape == 8:
        i = 0
        while True:
            p_i = i * (3 * i - 2)
            if end <= p_i:
                return number_list
            elif start <= p_i:
                number_list.append(p_i)
            i += 1

    else:
        return None


def is_cyclic(a, b):
    if a % 100 == b // 100:
        return True
    else:
        return False


print(p061(3))
print(p061(6))
print('Completed in', time.time() - start_time, 'seconds')
